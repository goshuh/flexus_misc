#!/usr/bin/env python3

import os
import sys

import re
import numpy as np


class Stamp(object):

    def __init__(self, cid, time):
        self.cid  = cid
        self.time = time


def parse(dic, fn):
    pat  = re.compile(r'@(\d+) c(\d+) (\d+) (\d+)')

    if not os.path.isfile(fn):
        return

    # 32 cores at most
    temp = [[] for _ in range(32)]
    func = [[] for _ in range(32)]

    curr = 0
    prev = 0
    real = [[] for _ in range(32)]
    fake = [[] for _ in range(32)]

    rall = [0  for _ in range(32)]

    # ad hoc
    init = False
    last = 0
    loop = 0
    offs = 0
    bad  = 0

    end  = False

    with open(fn) as fd:
        for cs in fd:
            if cs.startswith('Simulation terminated by flexus.'):
                end = True
                break

            if not (mat := pat.match(cs)):
                continue

            time = int(mat.group(1))
            core = int(mat.group(2))
            key  = int(mat.group(3))
            val  = int(mat.group(4))

            t = temp[core]
            f = func[core]

            match key:
                case 1:
                    if t and t[-1].cid == val:
                        f.append(time - t.pop().time)
                    else:
                        t.append(Stamp(val, time))

                    curr = 0

                case 2:
                    # we must observe a jump in time
                    if not init and last and time - last > 100:
                        init = True

                    if not init:
                        last = time
                        continue

                    match curr:
                        case 0: # prev
                            prev = val

                        case 1: # real
                            todo = 0

                            if (diff := val - prev) < offs:
                                # the trace queue is shrinking
                                offs = diff
                                todo = val - last
                            else:
                                todo = val - prev - offs

                            # very unwanted thing happens: 100x longer latency than avg
                            if todo * len(real[core]) > rall[core] * 100:
                                todo = rall[core] // len(real[core])
                                offs = val - last
                                bad += 1

                            real[core].append(todo)
                            rall[core] += todo

                            # for the next iteration
                            last = val

                        case 2: # fake
                            fake[core].append(val - prev)

                            # the first iteration
                            # negate the effect of the trace queue
                            if loop == 0:
                                if (r := real[core].pop()) > (f := fake[core].pop()):
                                    offs = r - f

                    if curr == 2:
                        loop += 1
                        curr  = 0
                    else:
                        curr += 1

    if end:
        print(f'{fn} ({bad})', file = sys.stderr)
    else:
        print(f'{fn} not terminated', file = sys.stderr)

    def output(cds, name, arr):
        if not arr:
            return

        arr = np.array(arr)

        cds[name] = [
            arr.size,
            np.min(arr),
            np.mean(arr),
            np.median(arr),
            np.percentile(arr, 99)]

        with open(f'{fn}-{name}.out', 'w') as fd:
            for a in arr:
                print(a, file = fd)

    l = 0

    for dn in fn.split('/'):
        sp = dn.split('_')

        if len(sp) == 3:
            l = int(sp[1])
            n = int(sp[2])

    if not l:
        return

    lds = dic.setdefault(l, {})
    nds = lds.setdefault(n, {})

    for c in range(32):
        if func[c] or real[c] or fake[c]:
            cds = nds.setdefault(c, {})

            output(cds, 'func', func[c])
            output(cds, 'real', real[c])
            output(cds, 'fake', fake[c])


if __name__ == '__main__':
    if len(sys.argv) != 2:
        sys.exit(f'usage: {sys.argv[0]} <dir>')

    pat = re.compile(sys.argv[1])
    dic = {}

    for cur, _, fns in os.walk('.'):
        for fn in fns:
            fn = os.path.relpath(os.path.join(cur, fn), '.')

            if pat.match(fn):
                parse(dic, fn)

    out = []

    for l, lds in dic.items():
        for n, nds in lds.items():
            for c, cds in nds.items():
                for f, res in cds.items():
                    out.append([l, n, c, f] + res)

    for o in sorted(out):
        print(','.join(map(str, o)))
