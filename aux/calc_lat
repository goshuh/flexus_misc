#!/usr/bin/python3

import os
import sys

import re
import struct

import numpy as np


class Stamp(object):

    def __init__(self, cid, time):
        self.cid  = cid
        self.time = time


def parse(dic, fn):
    if not os.path.isfile(fn):
        return

    # 32 cores at most
    fake = [[] for _ in range(32)]
    real = [[] for _ in range(32)]
    user = [[] for _ in range(32)]
    iret = [[] for _ in range(32)]

    info = '@QQ'
    size = struct.calcsize(info)

    flag = 1
    init = 0
    prev = 0
    offs = 0

    print(fn, file = sys.stderr)

    with open(fn, 'rb') as fd:
        while True:
            if len(data := fd.read(size)) < size:
                break

            arg, wid = struct.unpack(info, data)

            if len(data := fd.read(wid)) < wid:
                break

            if arg:
                continue

            time, core, _, key, val = struct.unpack('@QQQQQ', data)

            match key:
                case 6:
                    if flag:
                        flag |= 0x02

                    init = val

                case 7:
                    if flag:
                        flag |= 0x04
                    else:
                        fake[core].append(val - init)

                    prev = val

                case 8:
                    if flag:
                        flag |= 0x08

                        if (diff := time - prev) > 0:
                            offs = diff
                            print(f'  {time} set {offs}')
                    else:
                        if (diff := time - prev) < offs:
                            offs = max(0, diff)
                            print(f'  {time} dec {offs}')

                        real[core].append(time - init - offs)

                case 9:
                    if flag:
                        flag |= 0x10
                    else:
                        user[core].append(val)

                case 10:
                    if flag:
                        flag |= 0x20
                    else:
                        iret[core].append(val)

            if flag == 0x3f:
                flag = 0

    def output(c, cds, name, arr):
        if not arr:
            return

        arr = np.array(arr)

        cds[name] = [
            arr.size,
            np.min(arr),
            np.mean(arr),
            np.median(arr),
            np.percentile(arr, 99)]

        with open(f'{os.path.splitext(fn)[0]}-{c}-{name}.out', 'w') as fd:
            for a in arr:
                print(a, file = fd)

    l = 0

    for dn in fn.split('/'):
        sp = dn.split('_')

        if len(sp) == 4:
            l = int(sp[2])
            n = int(sp[3])
            break

    if not l:
        l = 0
        n = 0

    lds = dic.setdefault(l, {})
    nds = lds.setdefault(n, {})

    for c in range(32):
        if fake[c] or real[c] or user[c] or iret[c]:
            cds = nds.setdefault(c, {})

            output(c, cds, 'fake', fake[c])
            output(c, cds, 'real', real[c])
            output(c, cds, 'user', user[c])
            output(c, cds, 'iret', iret[c])


def traverse(dir):
    sub = list(map(re.compile, dir.split(os.sep)))

    def iterate(top, dep):
        end = dep == len(sub) - 1

        for f in os.listdir(top):
            if sub[dep].match(f):
                cur = os.path.join(top, f)

                if end:
                    yield cur
                elif os.path.isdir(cur):
                    yield from iterate(cur, dep + 1)

    yield from iterate('.', 0)


if __name__ == '__main__':
    if len(sys.argv) != 2:
        sys.exit(f'usage: {sys.argv[0]} <dir>')

    dic = {}
    out = []

    for fn in traverse(sys.argv[1]):
        parse(dic, fn)

    for l, lds in dic.items():
        for n, nds in lds.items():
            for c, cds in nds.items():
                for f, res in cds.items():
                    out.append((c, f, n, l, *res))

    for o in sorted(out):
        print(','.join(map(str, o)))
