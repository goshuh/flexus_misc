#!/usr/bin/env python3

import os
import sys

import re
import struct

import numpy as np


class Stamp(object):

    def __init__(self, cid, time):
        self.cid  = cid
        self.time = time


def parse(dic, fn):
    if not os.path.isfile(fn):
        return

    # 32 cores at most
    real = [[] for _ in range(32)]
    fake = [[] for _ in range(32)]

    info = '@QQ'
    size = struct.calcsize(info)

    with open(fn, 'rb') as fd:
        while True:
            if len(data := fd.read(size)) < size:
                break

            arg, wid = struct.unpack(info, data)

            if len(data := fd.read(wid)) < wid:
                break

            if arg:
                continue

            time, core, _, key, val = struct.unpack('@QQQQQ', data)

            match key:
                case 4:
                    real[core].append(val)

                case 5:
                    fake[core].append(val)

    print(fn, file = sys.stderr)

    def output(cds, name, arr):
        if not arr:
            return

        arr = np.array(arr)

        cds[name] = [
            arr.size,
            np.min(arr),
            np.mean(arr),
            np.median(arr),
            np.percentile(arr, 99)]

        with open(f'{fn}-{name}.out', 'w') as fd:
            for a in arr:
                print(a, file = fd)

    l = 0

    for dn in fn.split('/'):
        sp = dn.split('_')

        if len(sp) == 4:
            l = int(sp[2])
            n = int(sp[3])
            break

    if not l:
        return

    lds = dic.setdefault(l, {})
    nds = lds.setdefault(n, {})

    for c in range(32):
        if real[c] or fake[c]:
            cds = nds.setdefault(c, {})

            output(cds, 'real', real[c])
            output(cds, 'fake', fake[c])


def traverse(dir):
    sub = list(map(re.compile, dir.split(os.sep)))

    def iterate(top, dep):
        end = dep == len(sub) - 1

        for f in os.listdir(top):
            if sub[dep].match(f):
                cur = os.path.join(top, f)

                if end:
                    yield cur
                elif os.path.isdir(cur):
                    yield from iterate(cur, dep + 1)

    yield from iterate('.', 0)


if __name__ == '__main__':
    if len(sys.argv) != 2:
        sys.exit(f'usage: {sys.argv[0]} <dir>')

    dic = {}
    out = []

    for fn in traverse(sys.argv[1]):
        parse(dic, fn)

    for l, lds in dic.items():
        for n, nds in lds.items():
            for c, cds in nds.items():
                for f, res in cds.items():
                    out.append([l, n, c, f] + res)

    for o in sorted(out):
        print(','.join(map(str, o)))
